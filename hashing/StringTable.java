package hashing;

//
// STRINGTABLE.JAVA
// A hash table mapping Strings to their positions in the the pattern sequence
// You get to fill in the methods for this part.
//
public class StringTable {    
	    public Record hash[];
	    public Record hash2[];
	    public int m; // int the table size
	    public int M;
	    public int n; // int the load factor
	    public double a;
	    public int slot;
	//
    // Create an empty table big enough to hold maxSize records.
    //
	    public StringTable(int maxSize) {
	    	int n = 0;
	    	while (Math.pow (2, n) < maxSize) {
	    	   n++;
	    	}
	    	m = (int) Math.pow(2, n);
	    	this.hash = new Record[m];
	    } 
    //
    // Insert a Record r into the table.  Return true if
    // successful, false if the table is full.  You shouldn't ever
    // get two insertions with the same key value, but you may
    // simply return false if this happens.
    //
    public boolean insert(Record r) { 
    	int k = toHashKey(r.key);
    	int h1 = baseHash(k);
    	int h2 = stepHash(k);
    	int slot = h1 % m;
    	int n = 0;
    	while ((hash[slot] != null) && (n < m)) {
    		if(hash[slot].key == r.key) return false;
    		slot = (slot + h2) % m;
    		n++;
    		a = n / hash.length;
        	if (a >= 0.25) enlarge();	
    	}   	
    	hash[slot] = r;   	
    	return true;
    }
    
    
    void enlarge() {
    	Record hash2[] = hash;
    	hash = new Record[2 * hash2.length];
    	for (int i = 0; i < hash2.length; i++) {
    		if (hash2[i] != null) insert(hash2[i]); 
    	}
    }
    
    
    //
    // Delete a Record r from the table.  Note that you'll have to
    // find the record first unless you keep some extra information
    // in the Record structure.
    //
    public void remove(Record r) {
    	int k = toHashKey(r.key);
    	int h1 = baseHash(k);
    	int h2 = stepHash(k);
    	int slot = h1 % m;
    	int i = 0;
    	while (hash[slot] != null && i < m) {
    		if (hash[slot].key == r.key) hash[slot].key = "X";
    		slot = (slot + h2) % m;
   			i++;
    	}	
    }
    
    
    //
    // Find a record with a key matching the input.  Return the
    // record if it exists, or null if no matching record is found.
    //
    public Record find(String key) {
    	int k = toHashKey(key);
    	int h1 = baseHash(k);
    	int h2 = stepHash(k);
    	int slot = h1 % m;
    	int i = 0;
    	while (hash[slot] != null && i < m)	{
			if (hash[slot].key.equals(key))	return hash[slot];
			slot = (slot + h2) % m;
			i++;
    	}
    	return null;    	
    }
    
    
    
    
    ///////////////////////////////////////////////////////////////////////
    
    
    // Convert a String key into an integer that serves as input to hash
    // functions.  This mapping is based on the idea of a linear-congruential
    // pesudorandom number generator, in which successive values r_i are 
    // generated by computing
    //    r_i = ( A * r_(i-1) + B ) mod M
    // A is a large prime number, while B is a small increment thrown in
    // so that we don't just compute successive powers of A mod M.
    //
    // We modify the above generator by perturbing each r_i, adding in
    // the ith character of the string and its offset, to alter the
    // pseudorandom sequence.
    //
    int toHashKey(String s) {
		int A = 1952786893;
		int B = 367257;
		int v = B;
		
		for (int j = 0; j < s.length(); j++) {
			char c = s.charAt(j);
			v = A * (v + (int) c + j) + B;
		}
		
		if (v < 0) v = -v;
		return v;
    }
    
    int baseHash(int hashKey)
    {
    	int k = hashKey;
    	double A = (Math.sqrt(3) - 1);
    	int h1 = ((int) Math.floor(m * (k * A - Math.floor(k * A)))) % m;
    	return h1;
    	// Fill in your own hash function here
    }
    
    int stepHash(int hashKey)
    {
    	int k = hashKey;
    	double A = (Math.sqrt(5) - 1)/2;
    	int h2 = ((int) Math.floor(m * (k * A - Math.floor(k * A)))) % m;
    	return h2;
    	// Fill in your own hash function here
    }
}
